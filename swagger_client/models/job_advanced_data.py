# coding: utf-8

"""
    Runai API

    # Introduction  The Run:AI Control-Plane API reference is a guide that provides an easy-to-use programming interface for adding various tasks to your application, including workload submission, resource management, and administrative operations.  Run:ai APIs are accessed using *bearer tokens*. To obtain a token, you need to create an **Application** through the Run:ai user interface. To create an application, in your UI, go to `Settings & Tools`, `Application` and create a new Application.  After you have created a new application, you will need to assign it access rules. To assign access rules to the application, see [Create access rules](https://docs.run.ai/latest/admin/runai-setup/access-control/rbac/?h=create+delete+app#create-or-delete-rules). Make sure you assign the correct rules to your application. Use the [Roles](https://docs.run.ai/latest/admin/runai-setup/access-control/rbac/?h=create+delete+app#roles) to assign the correct access rules.  To get your access token, follow the instructions in [Request a token](https://docs.run.ai/latest/developer/rest-auth/#request-an-api-token).   # noqa: E501

    OpenAPI spec version: 2.18
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class JobAdvancedData(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'idle_seconds': 'float',
        'gr_engine_active': 'float',
        'dram_active': 'float',
        'sm_active': 'float',
        'sm_occupancy': 'float',
        'pipe_tensor_active': 'float',
        'pipe_fp64_active': 'float',
        'pipe_fp32_active': 'float',
        'pipe_fp16_active': 'float',
        'nvlink_tx_bytes': 'float',
        'nvlink_rx_bytes': 'float',
        'pcie_tx_bytes': 'float',
        'pcie_rx_bytes': 'float'
    }

    attribute_map = {
        'idle_seconds': 'idleSeconds',
        'gr_engine_active': 'grEngineActive',
        'dram_active': 'dramActive',
        'sm_active': 'smActive',
        'sm_occupancy': 'smOccupancy',
        'pipe_tensor_active': 'pipeTensorActive',
        'pipe_fp64_active': 'pipeFp64Active',
        'pipe_fp32_active': 'pipeFp32Active',
        'pipe_fp16_active': 'pipeFp16Active',
        'nvlink_tx_bytes': 'nvlinkTxBytes',
        'nvlink_rx_bytes': 'nvlinkRxBytes',
        'pcie_tx_bytes': 'pcieTxBytes',
        'pcie_rx_bytes': 'pcieRxBytes'
    }

    def __init__(self, idle_seconds=None, gr_engine_active=None, dram_active=None, sm_active=None, sm_occupancy=None, pipe_tensor_active=None, pipe_fp64_active=None, pipe_fp32_active=None, pipe_fp16_active=None, nvlink_tx_bytes=None, nvlink_rx_bytes=None, pcie_tx_bytes=None, pcie_rx_bytes=None):  # noqa: E501
        """JobAdvancedData - a model defined in Swagger"""  # noqa: E501
        self._idle_seconds = None
        self._gr_engine_active = None
        self._dram_active = None
        self._sm_active = None
        self._sm_occupancy = None
        self._pipe_tensor_active = None
        self._pipe_fp64_active = None
        self._pipe_fp32_active = None
        self._pipe_fp16_active = None
        self._nvlink_tx_bytes = None
        self._nvlink_rx_bytes = None
        self._pcie_tx_bytes = None
        self._pcie_rx_bytes = None
        self.discriminator = None
        if idle_seconds is not None:
            self.idle_seconds = idle_seconds
        if gr_engine_active is not None:
            self.gr_engine_active = gr_engine_active
        if dram_active is not None:
            self.dram_active = dram_active
        if sm_active is not None:
            self.sm_active = sm_active
        if sm_occupancy is not None:
            self.sm_occupancy = sm_occupancy
        if pipe_tensor_active is not None:
            self.pipe_tensor_active = pipe_tensor_active
        if pipe_fp64_active is not None:
            self.pipe_fp64_active = pipe_fp64_active
        if pipe_fp32_active is not None:
            self.pipe_fp32_active = pipe_fp32_active
        if pipe_fp16_active is not None:
            self.pipe_fp16_active = pipe_fp16_active
        if nvlink_tx_bytes is not None:
            self.nvlink_tx_bytes = nvlink_tx_bytes
        if nvlink_rx_bytes is not None:
            self.nvlink_rx_bytes = nvlink_rx_bytes
        if pcie_tx_bytes is not None:
            self.pcie_tx_bytes = pcie_tx_bytes
        if pcie_rx_bytes is not None:
            self.pcie_rx_bytes = pcie_rx_bytes

    @property
    def idle_seconds(self):
        """Gets the idle_seconds of this JobAdvancedData.  # noqa: E501


        :return: The idle_seconds of this JobAdvancedData.  # noqa: E501
        :rtype: float
        """
        return self._idle_seconds

    @idle_seconds.setter
    def idle_seconds(self, idle_seconds):
        """Sets the idle_seconds of this JobAdvancedData.


        :param idle_seconds: The idle_seconds of this JobAdvancedData.  # noqa: E501
        :type: float
        """

        self._idle_seconds = idle_seconds

    @property
    def gr_engine_active(self):
        """Gets the gr_engine_active of this JobAdvancedData.  # noqa: E501

        The fraction of time any portion of the graphics or compute engines were active  # noqa: E501

        :return: The gr_engine_active of this JobAdvancedData.  # noqa: E501
        :rtype: float
        """
        return self._gr_engine_active

    @gr_engine_active.setter
    def gr_engine_active(self, gr_engine_active):
        """Sets the gr_engine_active of this JobAdvancedData.

        The fraction of time any portion of the graphics or compute engines were active  # noqa: E501

        :param gr_engine_active: The gr_engine_active of this JobAdvancedData.  # noqa: E501
        :type: float
        """

        self._gr_engine_active = gr_engine_active

    @property
    def dram_active(self):
        """Gets the dram_active of this JobAdvancedData.  # noqa: E501

        The fraction of cycles where data was sent to or received from device memory  # noqa: E501

        :return: The dram_active of this JobAdvancedData.  # noqa: E501
        :rtype: float
        """
        return self._dram_active

    @dram_active.setter
    def dram_active(self, dram_active):
        """Sets the dram_active of this JobAdvancedData.

        The fraction of cycles where data was sent to or received from device memory  # noqa: E501

        :param dram_active: The dram_active of this JobAdvancedData.  # noqa: E501
        :type: float
        """

        self._dram_active = dram_active

    @property
    def sm_active(self):
        """Gets the sm_active of this JobAdvancedData.  # noqa: E501

        The fraction of time at least one warp was active on a multiprocessor, averaged over all multiprocessors  # noqa: E501

        :return: The sm_active of this JobAdvancedData.  # noqa: E501
        :rtype: float
        """
        return self._sm_active

    @sm_active.setter
    def sm_active(self, sm_active):
        """Sets the sm_active of this JobAdvancedData.

        The fraction of time at least one warp was active on a multiprocessor, averaged over all multiprocessors  # noqa: E501

        :param sm_active: The sm_active of this JobAdvancedData.  # noqa: E501
        :type: float
        """

        self._sm_active = sm_active

    @property
    def sm_occupancy(self):
        """Gets the sm_occupancy of this JobAdvancedData.  # noqa: E501

        The fraction of resident warps on a multiprocessor, relative to the maximum number of concurrent warps supported on a multiprocessor  # noqa: E501

        :return: The sm_occupancy of this JobAdvancedData.  # noqa: E501
        :rtype: float
        """
        return self._sm_occupancy

    @sm_occupancy.setter
    def sm_occupancy(self, sm_occupancy):
        """Sets the sm_occupancy of this JobAdvancedData.

        The fraction of resident warps on a multiprocessor, relative to the maximum number of concurrent warps supported on a multiprocessor  # noqa: E501

        :param sm_occupancy: The sm_occupancy of this JobAdvancedData.  # noqa: E501
        :type: float
        """

        self._sm_occupancy = sm_occupancy

    @property
    def pipe_tensor_active(self):
        """Gets the pipe_tensor_active of this JobAdvancedData.  # noqa: E501

        The fraction of cycles the tensor (HMMA / IMMA) pipe was active  # noqa: E501

        :return: The pipe_tensor_active of this JobAdvancedData.  # noqa: E501
        :rtype: float
        """
        return self._pipe_tensor_active

    @pipe_tensor_active.setter
    def pipe_tensor_active(self, pipe_tensor_active):
        """Sets the pipe_tensor_active of this JobAdvancedData.

        The fraction of cycles the tensor (HMMA / IMMA) pipe was active  # noqa: E501

        :param pipe_tensor_active: The pipe_tensor_active of this JobAdvancedData.  # noqa: E501
        :type: float
        """

        self._pipe_tensor_active = pipe_tensor_active

    @property
    def pipe_fp64_active(self):
        """Gets the pipe_fp64_active of this JobAdvancedData.  # noqa: E501

        The fraction of cycles the FP64 (double precision) pipe was active  # noqa: E501

        :return: The pipe_fp64_active of this JobAdvancedData.  # noqa: E501
        :rtype: float
        """
        return self._pipe_fp64_active

    @pipe_fp64_active.setter
    def pipe_fp64_active(self, pipe_fp64_active):
        """Sets the pipe_fp64_active of this JobAdvancedData.

        The fraction of cycles the FP64 (double precision) pipe was active  # noqa: E501

        :param pipe_fp64_active: The pipe_fp64_active of this JobAdvancedData.  # noqa: E501
        :type: float
        """

        self._pipe_fp64_active = pipe_fp64_active

    @property
    def pipe_fp32_active(self):
        """Gets the pipe_fp32_active of this JobAdvancedData.  # noqa: E501

        The fraction of cycles the FMA (FP32 (single precision), and integer) pipe was active  # noqa: E501

        :return: The pipe_fp32_active of this JobAdvancedData.  # noqa: E501
        :rtype: float
        """
        return self._pipe_fp32_active

    @pipe_fp32_active.setter
    def pipe_fp32_active(self, pipe_fp32_active):
        """Sets the pipe_fp32_active of this JobAdvancedData.

        The fraction of cycles the FMA (FP32 (single precision), and integer) pipe was active  # noqa: E501

        :param pipe_fp32_active: The pipe_fp32_active of this JobAdvancedData.  # noqa: E501
        :type: float
        """

        self._pipe_fp32_active = pipe_fp32_active

    @property
    def pipe_fp16_active(self):
        """Gets the pipe_fp16_active of this JobAdvancedData.  # noqa: E501

        The fraction of cycles the FP16 (half precision) pipe was active  # noqa: E501

        :return: The pipe_fp16_active of this JobAdvancedData.  # noqa: E501
        :rtype: float
        """
        return self._pipe_fp16_active

    @pipe_fp16_active.setter
    def pipe_fp16_active(self, pipe_fp16_active):
        """Sets the pipe_fp16_active of this JobAdvancedData.

        The fraction of cycles the FP16 (half precision) pipe was active  # noqa: E501

        :param pipe_fp16_active: The pipe_fp16_active of this JobAdvancedData.  # noqa: E501
        :type: float
        """

        self._pipe_fp16_active = pipe_fp16_active

    @property
    def nvlink_tx_bytes(self):
        """Gets the nvlink_tx_bytes of this JobAdvancedData.  # noqa: E501

        The rate of data transmitted over NVLink, not including protocol headers, in bytes per second  # noqa: E501

        :return: The nvlink_tx_bytes of this JobAdvancedData.  # noqa: E501
        :rtype: float
        """
        return self._nvlink_tx_bytes

    @nvlink_tx_bytes.setter
    def nvlink_tx_bytes(self, nvlink_tx_bytes):
        """Sets the nvlink_tx_bytes of this JobAdvancedData.

        The rate of data transmitted over NVLink, not including protocol headers, in bytes per second  # noqa: E501

        :param nvlink_tx_bytes: The nvlink_tx_bytes of this JobAdvancedData.  # noqa: E501
        :type: float
        """

        self._nvlink_tx_bytes = nvlink_tx_bytes

    @property
    def nvlink_rx_bytes(self):
        """Gets the nvlink_rx_bytes of this JobAdvancedData.  # noqa: E501

        The rate of data received over NVLink, not including protocol headers, in bytes per second  # noqa: E501

        :return: The nvlink_rx_bytes of this JobAdvancedData.  # noqa: E501
        :rtype: float
        """
        return self._nvlink_rx_bytes

    @nvlink_rx_bytes.setter
    def nvlink_rx_bytes(self, nvlink_rx_bytes):
        """Sets the nvlink_rx_bytes of this JobAdvancedData.

        The rate of data received over NVLink, not including protocol headers, in bytes per second  # noqa: E501

        :param nvlink_rx_bytes: The nvlink_rx_bytes of this JobAdvancedData.  # noqa: E501
        :type: float
        """

        self._nvlink_rx_bytes = nvlink_rx_bytes

    @property
    def pcie_tx_bytes(self):
        """Gets the pcie_tx_bytes of this JobAdvancedData.  # noqa: E501

        The rate of data transmitted over the PCIe bus, including both protocol headers and data payloads, in bytes per second  # noqa: E501

        :return: The pcie_tx_bytes of this JobAdvancedData.  # noqa: E501
        :rtype: float
        """
        return self._pcie_tx_bytes

    @pcie_tx_bytes.setter
    def pcie_tx_bytes(self, pcie_tx_bytes):
        """Sets the pcie_tx_bytes of this JobAdvancedData.

        The rate of data transmitted over the PCIe bus, including both protocol headers and data payloads, in bytes per second  # noqa: E501

        :param pcie_tx_bytes: The pcie_tx_bytes of this JobAdvancedData.  # noqa: E501
        :type: float
        """

        self._pcie_tx_bytes = pcie_tx_bytes

    @property
    def pcie_rx_bytes(self):
        """Gets the pcie_rx_bytes of this JobAdvancedData.  # noqa: E501

        The rate of data received over the PCIe bus, including both protocol headers and data payloads, in bytes per second  # noqa: E501

        :return: The pcie_rx_bytes of this JobAdvancedData.  # noqa: E501
        :rtype: float
        """
        return self._pcie_rx_bytes

    @pcie_rx_bytes.setter
    def pcie_rx_bytes(self, pcie_rx_bytes):
        """Sets the pcie_rx_bytes of this JobAdvancedData.

        The rate of data received over the PCIe bus, including both protocol headers and data payloads, in bytes per second  # noqa: E501

        :param pcie_rx_bytes: The pcie_rx_bytes of this JobAdvancedData.  # noqa: E501
        :type: float
        """

        self._pcie_rx_bytes = pcie_rx_bytes

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(JobAdvancedData, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, JobAdvancedData):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
